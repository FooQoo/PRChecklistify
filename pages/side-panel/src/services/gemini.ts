// Gemini API integration for PR checklist generation
import type { PRAnalysisResult, PRData, PRFile, ChecklistItemStatus } from '@src/types';
import { GoogleGenerativeAI } from '@google/generative-ai';
import type { ModelClient } from './modelClient';
import { languagePreferenceStorage } from './openai';

export interface GeminiConfig {
  apiKey: string;
  model: string;
}

class GeminiClient implements ModelClient {
  private client: GoogleGenerativeAI;
  private model: string;

  constructor(config: GeminiConfig) {
    this.client = new GoogleGenerativeAI(config.apiKey);
    this.model = config.model || 'gemini-1.5-pro';
  }

  /**
   * Analyze a PR and generate checklist and summary
   */
  async analyzePR(prData: PRData, languageOverride?: string): Promise<PRAnalysisResult> {
    try {
      // Get language preference from storage or use override if provided
      const language = languageOverride || (await languagePreferenceStorage.get()) || navigator.language || 'en';

      console.log(`Using language for analysis: ${language}`);
      const prompt = this.buildPRAnalysisPrompt(prData, language);
      const response = await this.callGemini(prompt);
      return this.parseAnalysisResponse(prompt, response);
    } catch (error) {
      console.error('Error analyzing PR with Gemini:', error);
      throw new Error('Failed to analyze PR with Gemini');
    }
  }

  /**
   * Build the prompt for PR analysis with language preference
   */
  private buildPRAnalysisPrompt(prData: PRData, language: string = 'en'): string {
    // Format the PR data for the prompt
    const { title, body, files } = prData;

    // List of changed files with stats and patches
    const fileChanges = files
      .map((file: PRFile) => {
        return `
File: ${file.filename} (${file.status})
Changes: +${file.additions} -${file.deletions}
${file.patch ? `Patch:\n${file.patch}` : 'No patch available'}
`;
      })
      .join('\n---\n');

    // Determine output language based on browser's language setting
    const outputLanguage = language.startsWith('ja') ? 'Japanese' : language.startsWith('ko') ? 'Korean' : 'English';

    // Construct the full prompt with language instruction
    return `
Analyze this pull request and provide your response in Japanese. Include:
Do not omit or summarize any file. Include all changed files in the output.

1. (Must Require) A summary of the PR, including:
   * Background
   * Problem being solved
   * Solution approach
   * Implementation details

2. (Must Require) For each changed file, create an explanation of the changes, focusing on:
   * Why the changes were made
   * How they relate to the overall PR
   * Any specific areas of concern or interest
   * Any additional context that would help in the review

3. (Optional) For each changed file, create a checklist of specific items to review, focusing on:
   * Background and problem being solved
   * Code correctness
   * Best practices
   * Potential bugs
   * Performance concerns
   * Security implications
   * Code is well-formatted and consistent with project style

### Additional instructions for file analysis:

* **All changed files must be included** in the fileAnalysis output. Do not omit any file.
* For **core logic files, UI components, specifications, and tests**, generate detailed checklist items with:
  * description: e.g. "Check that..." 
  * status: "PENDING".
* For **mock data files, slice files, and type definition files**, generate only one checklist item with:

  * description: e.g. "Low risk - review not required."
  * status: "OK"
* For **dist and other build artifacts**, generate only one checklist item with:

  * description: e.g. "Build artifact - review not required."
  * status: "OK"
* Provide a meaningful explanation for every file, even for mocks and dist files, summarizing why they changed and their role in the PR.

PR Title: ${title}
PR Description: ${body}

Changed Files:
${fileChanges}

Format your response as a JSON object with the following structure:
{
  "summary": "summary of the PR in ${outputLanguage}",
  "fileAnalysis": [
    {
      "id": "file-1",
      "filename": "path/to/file.ts",
      "explanation": "Update the checklist for this file generated by Gemini",
      "checklistItems": [
        {
          "id": "item_0",
          "description": "Check that...",
          "status": "PENDING"
        },
        ...more items
      ],
      "order": 1 // review order
    },
    ...more files
  ]
}

Important: All text content and checklist inside the JSON must be in ${outputLanguage}. Keep the JSON structure and field names in English.
`;
  }

  /**
   * Make the API call to Gemini
   */
  private async callGemini(prompt: string): Promise<string> {
    try {
      const generativeModel = this.client.getGenerativeModel({ model: this.model });

      // Systemプロンプトと本文を一緒に送信
      const systemPrompt =
        'You are a senior software developer conducting a thorough code review. You provide detailed, actionable feedback in JSON format as requested.';
      const fullPrompt = `${systemPrompt}\n\n${prompt}`;

      const result = await generativeModel.generateContent(fullPrompt);
      return result.response.text();
    } catch (error) {
      console.error('Error calling Gemini API:', error);
      throw error;
    }
  }

  /**
   * Stream chat completion from Gemini (for real-time chat UI)
   */
  async streamChatCompletion(
    messages: { role: 'user' | 'system' | 'assistant'; content: string }[],
    onToken: (token: string) => void,
    options?: { signal?: AbortSignal },
  ): Promise<void> {
    try {
      // Gemini用のモデルを取得
      const generativeModel = this.client.getGenerativeModel({
        model: this.model,
        generationConfig: {
          temperature: 0.3,
        },
      });

      // システムメッセージとユーザーメッセージを抽出
      const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';
      const userMessages = messages.filter(msg => msg.role === 'user').map(msg => msg.content);
      const assistantMessages = messages.filter(msg => msg.role === 'assistant').map(msg => msg.content);

      // 会話履歴を構築
      const chatHistory = [];
      const maxMessages = Math.max(userMessages.length, assistantMessages.length);

      for (let i = 0; i < maxMessages - 1; i++) {
        if (i < userMessages.length - 1) {
          chatHistory.push({ role: 'user', parts: [{ text: userMessages[i] }] });
        }
        if (i < assistantMessages.length) {
          chatHistory.push({ role: 'model', parts: [{ text: assistantMessages[i] }] });
        }
      }

      // 最後のユーザーメッセージ
      const lastUserMessage = userMessages[userMessages.length - 1];

      let result;
      if (chatHistory.length > 0) {
        // 会話履歴がある場合はチャットを開始
        const chat = generativeModel.startChat({
          history: chatHistory,
          systemInstruction: systemMessage,
        });

        const streamOptions = options?.signal ? { signal: options.signal } : undefined;
        result = await chat.sendMessageStream(lastUserMessage, streamOptions);
      } else {
        // 会話履歴がない場合は単一のリクエスト
        let content = lastUserMessage;
        if (systemMessage) {
          content = `${systemMessage}\n\n${content}`;
        }

        const streamOptions = options?.signal ? { signal: options.signal } : undefined;
        result = await generativeModel.generateContentStream(content, streamOptions);
      }

      for await (const chunk of result.stream) {
        const text = chunk.text();
        if (text) onToken(text);
      }
    } catch (error) {
      console.error('Error streaming Gemini chat completion:', error);
      throw error;
    }
  }

  /**
   * Parse the Gemini response into a structured format
   */
  private parseAnalysisResponse(prompt: string, responseText: string): PRAnalysisResult {
    try {
      // Parse the JSON response
      const parsedResponse = JSON.parse(responseText) as {
        summary: string;
        fileAnalysis: Array<{
          id?: string;
          filename: string;
          explanation: string;
          checklistItems: Array<{ id?: string; description: string; status?: string }>;
          order: number;
        }>;
      };

      // マッピング関数を作成して文字列からChecklistItemStatusに変換
      const mapStatus = (status?: string): ChecklistItemStatus => {
        if (status === 'OK' || status === 'WARNING' || status === 'ERROR' || status === 'PENDING') {
          return status as ChecklistItemStatus;
        }
        return 'PENDING';
      };

      // Ensure all file checklist items have IDs
      const fileAnalysis = parsedResponse.fileAnalysis.map((fileChecklist, fileIndex) => ({
        id: fileChecklist.id || `file-${fileIndex}`,
        filename: fileChecklist.filename,
        explanation: fileChecklist.explanation,
        checklistItems: fileChecklist.checklistItems.map((item, index) => ({
          id: item.id || `${fileChecklist.filename}-item-${index}`,
          description: item.description,
          status: mapStatus(item.status),
        })),
        order: fileChecklist.order,
      }));

      return {
        summary: parsedResponse.summary,
        fileAnalysis: fileAnalysis,
        prompt: prompt + '\n\nFinally, you should format the JSON output in a human-readable way.',
      };
    } catch (error) {
      console.error('Error parsing Gemini response:', error);
      throw new Error('Failed to parse Gemini response');
    }
  }
}

// Gemini API key storage
export const geminiApiKeyStorage = {
  get: async (): Promise<string | null> => {
    try {
      const result = await chrome.storage.local.get('geminiApiKey');
      return result.geminiApiKey || null;
    } catch (error) {
      console.error('Error getting Gemini API key:', error);
      return null;
    }
  },
  set: async (apiKey: string): Promise<void> => {
    try {
      await chrome.storage.local.set({ geminiApiKey: apiKey });
    } catch (error) {
      console.error('Error setting Gemini API key:', error);
      throw error;
    }
  },
  clear: async (): Promise<void> => {
    try {
      await chrome.storage.local.remove('geminiApiKey');
    } catch (error) {
      console.error('Error clearing Gemini API key:', error);
      throw error;
    }
  },
};

// Create and export Gemini client instance
export const createGeminiClient = async (): Promise<GeminiClient | null> => {
  const apiKey = await geminiApiKeyStorage.get();
  if (!apiKey) {
    return null;
  }
  return new GeminiClient({
    apiKey,
    model: 'gemini-1.5-pro',
  });
};

export default GeminiClient;
