// OpenAI API integration for PR checklist generation
import type { PRAnalysisResult, PRData, PRFile, ChecklistItemStatus } from '@src/types';
import { OpenAI } from 'openai';
import type { ModelClient } from './modelClient';
import type { Language } from '@extension/storage';
import { getLanguageLabel } from '@extension/storage';

export interface OpenAIConfig {
  apiKey: string;
  model: string;
  apiEndpoint?: string;
}

class OpenAIClient implements ModelClient {
  private client: OpenAI;
  private model: string;

  constructor(config: OpenAIConfig) {
    this.client = new OpenAI({
      apiKey: config.apiKey,
      baseURL: config.apiEndpoint,
      dangerouslyAllowBrowser: true, // Add this flag to allow browser usage
    });
    this.model = config.model || 'gpt-4-turbo';
  }

  /**
   * Analyze a PR and generate checklist and summary
   */
  async analyzePR(prData: PRData, language: Language): Promise<PRAnalysisResult> {
    try {
      console.log(`Using language for analysis: ${getLanguageLabel(language)}`);
      const prompt = this.buildPRAnalysisPrompt(prData, language);
      const response = await this.callOpenAI(prompt);
      return this.parseAnalysisResponse(prompt, response);
    } catch (error) {
      console.error('Error analyzing PR with OpenAI:', error);
      throw new Error('Failed to analyze PR with OpenAI');
    }
  }

  /**
   * Build the prompt for PR analysis with language preference
   */
  private buildPRAnalysisPrompt(prData: PRData, language: Language): string {
    // Format the PR data for the prompt
    const { title, body, files } = prData;

    // List of changed files with stats and patches
    const fileChanges = files
      .map((file: PRFile) => {
        return `
File: ${file.filename} (${file.status})
Changes: +${file.additions} -${file.deletions}
${file.patch ? `Patch:\n${file.patch}` : 'No patch available'}
`;
      })
      .join('\n---\n');

    // Construct the full prompt with language instruction
    return `
Analyze this pull request and provide your response in Japanese. Include:
Do not omit or summarize any file. Include all changed files in the output.

1. (Must Require) A summary of the PR, including:
   * Background
   * Problem being solved
   * Solution approach
   * Implementation details

2. (Must Require) For each changed file, create an explanation of the changes, focusing on:
   * Why the changes were made
   * How they relate to the overall PR
   * Any specific areas of concern or interest
   * Any additional context that would help in the review

3. (Optional) For each changed file, create a checklist of specific items to review, focusing on:
   * Background and problem being solved
   * Code correctness
   * Best practices
   * Potential bugs
   * Performance concerns
   * Security implications
   * Code is well-formatted and consistent with project style

### Additional instructions for file analysis:

* **All changed files must be included** in the fileAnalysis output. Do not omit any file.
* For **core logic files, UI components, specifications, and tests**, generate detailed checklist items with:
  * description: e.g. "Check that..." 
  * status: "PENDING".
* For **mock data files, slice files, and type definition files**, generate only one checklist item with:

  * description: e.g. "Low risk - review not required."
  * status: "OK"
* For **dist and other build artifacts**, generate only one checklist item with:

  * description: e.g. "Build artifact - review not required."
  * status: "OK"
* Provide a meaningful explanation for every file, even for mocks and dist files, summarizing why they changed and their role in the PR.

PR Title: ${title}
PR Description: ${body}

Changed Files:
${fileChanges}

Format your response as a JSON object with the following structure:
{
  "summary": "summary of the PR in ${getLanguageLabel(language)}",
  "fileAnalysis": [
    {
      "id": "file-1",
      "filename": "path/to/file.ts",
      "explanation": "Update the checklist for this file generated by OpenAI",
      "checklistItems": [
        {
          "id": "item_0",
          "description": "Check that...",
          "status": "PENDING"
        },
        ...more items
      ],
      "order": 1 // review order
    },
    ...more files
  ]
}

Important: All text content and checklist inside the JSON must be in ${getLanguageLabel(language)}. Keep the JSON structure and field names in English.
`;
  }

  /**
   * Make the API call to OpenAI
   */
  private async callOpenAI(prompt: string): Promise<string> {
    try {
      const response = await this.client.chat.completions.create({
        model: this.model,
        messages: [
          {
            role: 'system',
            content:
              'You are a senior software developer conducting a thorough code review. You provide detailed, actionable feedback in JSON format as requested.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.3,
        response_format: { type: 'json_object' },
      });

      return response.choices[0].message.content || '';
    } catch (error) {
      console.error('Error calling OpenAI API:', error);
      throw error;
    }
  }

  /**
   * Stream chat completion from OpenAI (for real-time chat UI)
   */
  async streamChatCompletion(
    messages: { role: 'user' | 'system' | 'assistant'; content: string }[],
    onToken: (token: string) => void,
    options?: { signal?: AbortSignal },
  ): Promise<void> {
    try {
      const response = await this.client.chat.completions.create(
        {
          model: this.model,
          messages,
          temperature: 0.3,
          stream: true,
          response_format: { type: 'text' }, // JSONでなくtextで返す
        },
        { signal: options?.signal },
      );
      for await (const chunk of response) {
        const delta = chunk.choices?.[0]?.delta?.content;
        if (delta) onToken(delta);
      }
    } catch (error) {
      console.error('Error streaming OpenAI chat completion:', error);
      throw error;
    }
  }

  /**
   * Parse the OpenAI response into a structured format
   */
  private parseAnalysisResponse(prompt: string, responseText: string): PRAnalysisResult {
    try {
      // Parse the JSON response
      const parsedResponse = JSON.parse(responseText) as {
        summary: string;
        fileAnalysis: Array<{
          id?: string;
          filename: string;
          explanation: string;
          checklistItems: Array<{ id?: string; description: string; status?: string }>;
          order: number;
        }>;
      };

      // マッピング関数を作成して文字列からChecklistItemStatusに変換
      const mapStatus = (status?: string): ChecklistItemStatus => {
        if (status === 'OK' || status === 'WARNING' || status === 'ERROR' || status === 'PENDING') {
          return status as ChecklistItemStatus;
        }
        return 'PENDING';
      };

      // Ensure all file checklist items have IDs
      const fileAnalysis = parsedResponse.fileAnalysis.map((fileChecklist, fileIndex) => ({
        id: fileChecklist.id || `file-${fileIndex}`,
        filename: fileChecklist.filename,
        explanation: fileChecklist.explanation,
        checklistItems: fileChecklist.checklistItems.map((item, index) => ({
          id: item.id || `${fileChecklist.filename}-item-${index}`,
          description: item.description,
          status: mapStatus(item.status),
        })),
        order: fileChecklist.order,
      }));

      return {
        summary: parsedResponse.summary,
        fileAnalysis: fileAnalysis,
        prompt: prompt + '\n\nFinally, you should format the JSON output in a human-readable way.',
      };
    } catch (error) {
      console.error('Error parsing OpenAI response:', error);
      throw new Error('Failed to parse OpenAI response');
    }
  }
}

// Storage for OpenAI API key
export const openaiApiKeyStorage = {
  get: async (): Promise<string | null> => {
    try {
      const result = await chrome.storage.local.get('openaiApiKey');
      return result.openaiApiKey || null;
    } catch (error) {
      console.error('Error getting OpenAI API key:', error);
      return null;
    }
  },

  set: async (apiKey: string): Promise<void> => {
    try {
      await chrome.storage.local.set({ openaiApiKey: apiKey });
    } catch (error) {
      console.error('Error setting OpenAI API key:', error);
      throw error;
    }
  },

  clear: async (): Promise<void> => {
    try {
      await chrome.storage.local.remove('openaiApiKey');
    } catch (error) {
      console.error('Error clearing OpenAI API key:', error);
      throw error;
    }
  },
};

// Storage for language preference
export const languagePreferenceStorage = {
  get: async (): Promise<string | null> => {
    try {
      const result = await chrome.storage.local.get('languagePreference');
      return result.languagePreference || null;
    } catch (error) {
      console.error('Error getting language preference:', error);
      return null;
    }
  },

  set: async (language: string): Promise<void> => {
    try {
      await chrome.storage.local.set({ languagePreference: language });
    } catch (error) {
      console.error('Error setting language preference:', error);
      throw error;
    }
  },

  clear: async (): Promise<void> => {
    try {
      await chrome.storage.local.remove('languagePreference');
    } catch (error) {
      console.error('Error clearing language preference:', error);
      throw error;
    }
  },
};

// Storage for OpenAI API endpoint
export const openaiApiEndpointStorage = {
  get: async (): Promise<string | null> => {
    try {
      const result = await chrome.storage.local.get('openaiApiEndpoint');
      return result.openaiApiEndpoint || null;
    } catch (error) {
      console.error('Error getting OpenAI API endpoint:', error);
      return null;
    }
  },

  set: async (endpoint: string): Promise<void> => {
    try {
      await chrome.storage.local.set({ openaiApiEndpoint: endpoint });
    } catch (error) {
      console.error('Error setting OpenAI API endpoint:', error);
      throw error;
    }
  },

  clear: async (): Promise<void> => {
    try {
      await chrome.storage.local.remove('openaiApiEndpoint');
    } catch (error) {
      console.error('Error clearing OpenAI API endpoint:', error);
      throw error;
    }
  },
};

// Create and export OpenAI client instance
export const createOpenAIClient = async (): Promise<OpenAIClient | null> => {
  const apiKey = await openaiApiKeyStorage.get();
  if (!apiKey) {
    return null;
  }

  // APIエンドポイントを取得
  const apiEndpoint = await openaiApiEndpointStorage.get();

  return new OpenAIClient({
    apiKey,
    model: 'gpt-4o',
    apiEndpoint: apiEndpoint || '',
  });
};

export default OpenAIClient;
